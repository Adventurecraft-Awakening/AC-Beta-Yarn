buildscript {
	repositories {
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
		maven {
			name = 'Quilt'
			url = 'https://maven.quiltmc.org/repository/release'
		}
		maven {
			name "Jitpack"
			url 'https://jitpack.io/'
		}
	}
	dependencies {
		classpath "cuchaz:enigma:${project.enigma_version}"
		classpath "cuchaz:enigma-cli:${project.enigma_version}"
		classpath "commons-io:commons-io:2.6"
		classpath "org.apache.commons:commons-compress:1.19"
		classpath "com.google.guava:guava:28.0-jre"
		classpath 'de.undercouch:gradle-download-task:4.0.4'
		classpath 'net.fabricmc:tiny-remapper:0.1.0.40' //Newer versions will need createMappingsProvider updating
		classpath "com.github.Chocohead:Stitch:${project.stitch_hash}"
		classpath 'com.github.Chocohead:tiny-mappings-parser:d96d407'
		classpath 'org.codehaus.groovy:groovy-all:3.0.8'
	}
}

plugins {
	id 'de.undercouch.download' version '4.0.4'
	id 'maven-publish'
	id 'java'
}

def minecraft_version = "b1.7.3"

def ENV = System.getenv()
def build_number = ENV.GITHUB_ACTIONS ? ENV.BUILD_NUMBER : "local"

def yarnVersion = "${minecraft_version}-build.$build_number"

repositories {
	mavenCentral()
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
	maven {
		name = 'Quilt'
		url = 'https://maven.quiltmc.org/repository/release'
	}
	maven {
		name "Jitpack"
		url 'https://jitpack.io/'
	}
}

configurations {
	enigmaRuntime {
		resolutionStrategy {
			cacheDynamicVersionsFor 0, "seconds"
			cacheChangingModulesFor 0, "seconds"
		}
	}
}

dependencies {
	enigmaRuntime "cuchaz:enigma-swing:${project.enigma_version}"
	enigmaRuntime "com.github.Chocohead:Stitch:${project.stitch_hash}"
}

File mappingsDir = file("mappings")
File cacheFilesMinecraft = file(".gradle/minecraft")
File tempDir = file(".gradle/temp")
File mergedJar = file("${minecraft_version}-merged.jar")
File clientIntermediaryJar = new File(cacheFilesMinecraft, "${minecraft_version}-client-intermediary.jar")
File serverIntermediaryJar = new File(cacheFilesMinecraft, "${minecraft_version}-server-intermediary.jar")
File namedJar = file("${minecraft_version}-named.jar")
File versionFile = new File(cacheFilesMinecraft, "${minecraft_version}.json")
File clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
File serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")
File libraries = new File(cacheFilesMinecraft, "${minecraft_version}-libraries")
File libs = new File(buildDir, "libs")


import com.google.common.hash.Hashing
import com.google.common.io.Files
import cuchaz.enigma.command.CheckMappingsCommand
import cuchaz.enigma.command.MapSpecializedMethodsCommand
import groovy.io.FileType
import groovy.json.JsonSlurper
import net.fabricmc.mappings.*
import net.fabricmc.stitch.commands.CommandCorrectMappingUnions
import net.fabricmc.stitch.commands.CommandFixNesting
import net.fabricmc.stitch.commands.CommandMergeTiny
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.IMappingProvider
import net.fabricmc.tinyremapper.MemberInstance
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream
import org.apache.commons.io.FileUtils

import java.util.concurrent.TimeUnit
import java.util.zip.GZIPOutputStream

static boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		def hash = Files.asByteSource(file).hash(Hashing.sha256())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString() == checksum
	}
	return false
}

task downloadVersionsManifest {
	//inputs.property "mc_ver", minecraft_version
	inputs.property "currenttime", new Date()
	def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")
	logger.info(manifestFile.absolutePath)
	outputs.file(manifestFile)
	doLast {
		logger.lifecycle(":downloading minecraft versions manifest")
		if (manifestFile.exists()) {
			if (FileUtils.isFileOlder(manifestFile, System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(1, TimeUnit.DAYS))) {
				logger.info("Manifest was more than than 1 day old, redownloading.")
				FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
			} else {
				logger.info("Manifest already existed, and is up to date enough.")
			}
		} else {
			logger.info("Manifest did not exist, downloading.")
			FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
		}
	}
}

static def getManifestVersion(File manifestFile, String minecraft_version) {
	def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile, "UTF-8")) : null
	return manifest != null ? manifest.versions.stream().filter({
		(it.id == minecraft_version)
	}).findFirst() : java.util.Optional.empty()
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest) {
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

	//have to grab the release time as there's a current timestamp on each element?!
	inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

	outputs.file versionFile

	doLast {
		manifestVersion = getManifestVersion(manifestFile, minecraft_version)
		//nb need to re-read here in case it didn't exist before
		if (manifestVersion.isPresent() || versionFile.exists()) {

			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
			}
		} else {
			throw new RuntimeException("No version data for Minecraft version ${minecraft_version}")
		}
	}
}

task downloadMcJars(dependsOn: downloadWantedVersionManifest) {

	inputs.files versionFile

	outputs.files(clientJar, serverJar)

	outputs.upToDateWhen {
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, "UTF-8"))
		return clientJar.exists() && serverJar.exists() && validateChecksum(clientJar, version.downloads.client.sha1) && validateChecksum(serverJar, "2f90dc1cb5ca7e9d71786801b307390a67fcf954")
	}

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		//reload in case it changed
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, "UTF-8"))

		logger.lifecycle(":downloading minecraft jars")

		if (!clientJar.exists() || !validateChecksum(clientJar, version.downloads.client.sha1)) {
			logger.lifecycle(":downloading minecraft client")
			FileUtils.copyURLToFile(new URL(version.downloads.client.url), clientJar)
		}

		if (!serverJar.exists() || !validateChecksum(serverJar, "2f90dc1cb5ca7e9d71786801b307390a67fcf954")) {
			logger.lifecycle(":downloading minecraft server")
			URL url = new URL("https://cdn.discordapp.com/attachments/369990015096455168/500081541196546049/b1.7.3.zip")

			HttpURLConnection connection = (HttpURLConnection) url.openConnection()
			connection.setRequestProperty("User-Agent", "Mozilla/5.0") //Discord wants some kind of user agent before it lets you download things

			new ZipArchiveInputStream(connection.getInputStream()).with {stream ->
				ZipArchiveEntry entry
				while ((entry = stream.getNextZipEntry()) != null) {
					if ("b1.7.3/minecraft_server.jar" == entry.getName()) {
						FileUtils.copyToFile(stream, serverJar)
						break
					}
				}
			}
		}
	}
}

task downloadMcLibs(dependsOn: downloadWantedVersionManifest) {
	inputs.files versionFile

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, "UTF-8"))

		logger.lifecycle(":downloading minecraft libraries")

		if (!libraries.exists()) {
			libraries.mkdirs()
		}

		version.libraries.each {
			String downloadUrl = it.downloads?.artifact?.url
			if (downloadUrl == null) return
			// Lazy fix for some broken behaviour.
			if ((new File(libraries, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))).exists()) return

			download {
				src downloadUrl
				dest new File(libraries, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))
				overwrite false
			}
		}
	}
}

task downloadIntermediary(type: Download) {
	def url = "https://gist.githubusercontent.com/Chocohead/b7ea04058776495a93ed2d13f34d697a/raw/Beta 1.7.3 Merge.tiny"
	src url.replaceAll(" ", "%20")
	dest new File(cacheFilesMinecraft, "${minecraft_version}-intermediary.tiny")
}

task remapClientJar(dependsOn: [downloadMcJars, downloadMcLibs, downloadIntermediary]) {
	inputs.file clientJar
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file clientIntermediaryJar

	doLast {
		logger.lifecycle(":mapping client to intermediary")
		mapJar(clientIntermediaryJar, clientJar, downloadIntermediary.dest, libraries, "client", "intermediary")
	}
}

task remapServerJar(dependsOn: [downloadMcJars, downloadMcLibs, downloadIntermediary]) {
	inputs.file serverJar
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file serverIntermediaryJar

	doLast {
		logger.lifecycle(":mapping server to intermediary")
		mapJar(serverIntermediaryJar, serverJar, downloadIntermediary.dest, libraries, "server", "intermediary")
	}
}

task mergeJars(dependsOn: [remapClientJar, remapServerJar]) {
	inputs.files([clientIntermediaryJar, serverIntermediaryJar])
	outputs.file(mergedJar)

	doLast {
		logger.lifecycle(":merging jars")

		if (mergedJar.exists()) {
			return
		}

		def jarMerger = new JarMerger(clientIntermediaryJar, serverIntermediaryJar, mergedJar)
		jarMerger.merge()
		jarMerger.close()

		CommandFixNesting.run(mergedJar)
	}
}

task yarn(dependsOn: mergeJars) {
	doLast {
		ant.setLifecycleLogLevel "WARN"
		ant.java(
				classname: 'cuchaz.enigma.gui.Main',
				classpath: configurations.enigmaRuntime.asPath,
				fork: true,
				spawn: true
		) {
			jvmarg(value: "-Xmx2048m")
			arg(value: '-jar')
			arg(value: mergedJar.getAbsolutePath())
			arg(value: '-mappings')
			arg(value: mappingsDir.getAbsolutePath())
			arg(value: '-profile')
			arg(value: 'enigma_profile.json')
		}
	}
}

task buildEnigma(type: Zip) {
	from mappingsDir
	include "**/*"
	archiveName "yarn-enigma-${yarnVersion}.zip"
	destinationDir(libs)
}

task checkMappings {
	inputs.dir mappingsDir
	doLast {
		logger.lifecycle(":checking mappings")

		String[] args = [
				mergedJar.getAbsolutePath(),
				mappingsDir.getAbsolutePath()
		]

		new CheckMappingsCommand().run(args)
	}
}

task buildYarnTiny(dependsOn: "mergeJars", type: FileOutput) {
	inputs.dir mappingsDir
	if (!libs.exists()) {
		libs.mkdirs()
	}

	def yarnTiny = new File(tempDir, "yarn-mappings.tiny")
	fileOutput = yarnTiny

	outputs.upToDateWhen { return false }

	doLast {
		logger.lifecycle(":generating tiny mappings")

		new MapSpecializedMethodsCommand().run(
				mergedJar.getAbsolutePath(),
				'enigma',
				mappingsDir.getAbsolutePath(),
				'tiny:intermediary:named',
				yarnTiny.getAbsolutePath()
		)
	}
}

task mergeTiny(dependsOn: [downloadIntermediary, buildYarnTiny], type: FileOutput) {
	def yarnTinyInput = buildYarnTiny.fileOutput

	def outputFile = new File(tempDir, "mappings.tiny")
	outputs.file(outputFile)
	fileOutput = outputFile

	outputs.upToDateWhen { return false }

	doLast {
		logger.lifecycle(":merging yarn and intermediary")
		String[] args = [
				downloadIntermediary.dest.getAbsolutePath(),
				yarnTinyInput.getAbsolutePath(),
				outputFile.getAbsolutePath()
		]

		new CommandMergeTiny().run(args)
		CommandCorrectMappingUnions.run(outputFile.toPath(), "intermediary", "named")
	}
}

task tinyJar(type: Jar, dependsOn: "mergeTiny") {
	outputs.upToDateWhen { return false }
	archiveFileName.set "yarn-${yarnVersion}.jar"
	destinationDir(libs)
	archiveClassifier.set ""
	from(mergeTiny.fileOutput) {
		rename { "mappings/mappings.tiny" }
	}
}

task compressTiny(dependsOn: ["tinyJar", "mergeTiny"], type: FileOutput) {
	def outputFile = new File(libs, "yarn-tiny-${yarnVersion}.gz")
	outputs.file(outputFile)
	fileOutput = outputFile

	def inputFile = mergeTiny.fileOutput

	outputs.upToDateWhen { return false }

	doLast {
		logger.lifecycle(":compressing tiny mappings")

		def buffer = new byte[1024]
		def fileOutputStream = new FileOutputStream(outputFile)
		def outputStream = new GZIPOutputStream(fileOutputStream)
		def fileInputStream = new FileInputStream(inputFile)

		def length
		while ((length = fileInputStream.read(buffer)) > 0) {
			outputStream.write(buffer, 0, length)
		}

		fileInputStream.close()
		outputStream.finish()
		outputStream.close()
		inputFile.delete()
	}
}

clean.doFirst {
	delete tempDir, cacheFilesMinecraft
}

tasks.build.dependsOn "compressTiny"
tasks.build.dependsOn "buildEnigma"
tasks.build.dependsOn "tinyJar"

task mapNamedJar(dependsOn: [mergeJars, mergeTiny]) {
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(namedJar)

	//Force the task to always run
	outputs.upToDateWhen {
		return false
	}

	doLast {
		logger.lifecycle(":mapping minecraft to named")

		mapJar(namedJar, mergedJar, mergeTiny.fileOutput, libraries, "intermediary", "named")
	}
}

publishing {
	publications {
		maven(MavenPublication) {
			groupId 'com.halotroop'
			artifactId "yarn"
			version yarnVersion

			artifact(compressTiny.fileOutput) {
				classifier "tiny"
				builtBy compressTiny
			}
			artifact(buildEnigma) {
				classifier "enigma"
			}
			artifact(tinyJar)
		}
	}
	repositories {
		if (System.getenv().MAVEN_PUBLISH_TOKEN) {
			maven {
				url 'https://repo.blucobalt.dev/repository/maven-halotroop/'
				credentials {
					username 'halotroop2288'
					password System.getenv().MAVEN_PUBLISH_TOKEN
				}
				authentication {
					basic(BasicAuthentication)
				}
			}
		} else {
			mavenLocal()
		}
	}
}

static IMappingProvider createMappingsProvider(input, from, to) {
	Mappings mappings = MappingsProvider.readTinyMappings(java.nio.file.Files.newInputStream(input), false)
	return {classMap, fieldMap, methodMap ->
		for (ClassEntry entry : mappings.getClassEntries()) {
			classMap.put(entry.get(from), entry.get(to))
		}

		for (FieldEntry entry : mappings.getFieldEntries()) {
			EntryTriple fromTriple = entry.get(from)
			if (fromTriple == null) continue
			fieldMap.put(fromTriple.getOwner() + "/" + MemberInstance.getFieldId(fromTriple.getName(), fromTriple.getDesc()), entry.get(to).getName())
		}

		for (MethodEntry entry : mappings.getMethodEntries()) {
			EntryTriple fromTriple = entry.get(from)
			if (fromTriple == null) continue
			methodMap.put(fromTriple.getOwner() + "/" + MemberInstance.getMethodId(fromTriple.getName(), fromTriple.getDesc()), entry.get(to).getName())
		}
	}
}

static void mapJar(File output, File input, File mappings, File libraries, String from, String to) {
	if (output.exists()) {
		output.delete()
	}

	def remapper = TinyRemapper.newRemapper()
			.withMappings(createMappingsProvider(mappings.toPath(), from, to))
			.renameInvalidLocals(true)
			.rebuildSourceFilenames(true)
			.build()

	try {
		def outputConsumer = new OutputConsumerPath(output.toPath())
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		libraries.eachFileRecurse(FileType.FILES) { file ->
			remapper.readClassPath(file.toPath())
		}
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

class FileOutput extends DefaultTask {
	@OutputFile
	File fileOutput
}